#!/usr/bin/python3
import zlib
import matplotlib.pyplot as plt

class ElementaryCA:
    # 変わらない定数を設定, widthは世界の広さ(bit数)
    def __init__(self, rule, width):
        self.rule = rule
        self.width = width

    def step(self, state): # stateは全セルの状態を表す．
        next_state = 0
        # 現在のstateを3つの変数にコピーしてずらす．周期的境界条件も考慮する．
        left = (state << 1) | (state >> (self.width - 1)) # 全てのセルにとっての左側の状況
        center = state
        right = (state >> 1) | (state << (self.width - 1))
        # 周期境界条件
        for k in range(8):
            # k=5 (101) -> (left) & (~center) & (ritht)を作りたい
            
            # 左隣の条件
            if (k >> 2) & 1 == 1: # 1桁目以外は全て0 -> 2桁目の判定ができる 
                m_left = left
            else:
                m_left = ~left

            # 中心の条件
            if (k >> 1) & 1 == 1:
                m_center = center
            else:
                m_center = ~center

            # 右隣の条件
            if (k >> 0) & 1 == 1:
                m_right = right
            else:
                m_right = ~right

            # 全ての条件を満たす場所を特定
            pattern_mask = m_left & m_center & m_right

            # ruleのk桁目が1ならマスクで立っているところは全て立つ．
            if (self.rule >> k) & 1 == 1: # ruleのk桁目の判定
                next_state = next_state | pattern_mask # pattern kをnext_stateに追加

        return next_state & ((1 << self.width) - 1)
def run_experiment(rule, width, steps):
    ca = ElementaryCA(rule, width)
    state = 1 << (width // 2)

    compressed_sizes = []
    densities = []

    byte_length = (width + 7) // 8 # bitからbyteへ

    for _ in range(steps):
        # データをバイト列に変換
        state_bytes = state.to_bytes(byte_length, 'big')

        # 圧縮サイズの計測
        c_size = len(zlib.compress(state_bytes))
        compressed_sizes.append(c_size)

        # 密度の計算
        density = state.bit_count() / width
        densities.append(density)

        state = ca.step(state)

    return compressed_sizes, densities

if __name__ == "__main__":
    width = 512
    steps = 300
    rules = [30, 110]
    
    fig, axes = plt.subplots(2, 1, figsize=(10, 8), sharex=True)
    for i, rule in enumerate(rules):
        sizes, densities = run_experiment(rule, width, steps)

        ax = axes[i]
        
        # 圧縮サイズのプロット（メイン）
        color = 'tab:blue'
        ax.set_ylabel('Compressed Size (bytes)', color=color)
        ax.plot(sizes, color=color, label='Complexity (Zlib Size)')
        ax.tick_params(axis='y', labelcolor=color)
        ax.set_title(f'Rule {rule} Analysis')
        ax.grid(True, which='both', linestyle='--', alpha=0.5)
        
        # 密度のプロット（サブ：右軸）
        ax2 = ax.twinx()
        color = 'tab:orange'
        ax2.set_ylabel('Density (Ratio of 1s)', color=color)
        ax2.plot(densities, color=color, alpha=0.6, label='Density')
        ax2.tick_params(axis='y', labelcolor=color)
        ax2.set_ylim(0, 1.0)

    plt.xlabel('Time Step')
    plt.tight_layout()
    plt.show()
